%%
%% This is file `sample-acmsmall.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `acmsmall')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmsmall.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[acmsmall]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}


%%
%% These commands are for a JOURNAL article.
\acmJournal{TOCT}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%\usepackage{verbatim}

%%
%% end of the preamble, start of the body of the document source.
\usepackage{multirow}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{algorithm2e}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usetikzlibrary{automata,positioning}

\usepackage{listings}
\lstset{%%frame=single,
	language=Java,
	aboveskip=1mm,
	belowskip=1mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle=\footnotesize\ttfamily,
%	numbers=none,
%	numberstyle=\tiny\color{white},
	keywordstyle=\bf,
	otherkeywords={foreign,extern},
	commentstyle=\itshape,
	breaklines=true,
	breakatwhitespace=true,
	captionpos=b,
%	numbers=left,
%	numbersep=5pt,
%	rulecolor=\color{black},
	tabsize=3
}

%\newtheorem{theorem}{Theorem}
%\newtheorem{corollary}{Corollary}
%\newtheorem{definition}{Definition}
%\newtheorem{proc}{Procedure}
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Manual}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Ali Mahjur}
\email{mahjur@mut.ac.ir}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{Malek Ashtar University of Technology}
  \streetaddress{P.O. Box 1212}
  \city{Tehran}
  \state{Tehran}
  \country{Iran}}
  \postcode{43017-6221}


%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Ali Mahjur}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  This paper introduces a new computation model whose purpose is to facilitate the design of algorithms.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{datasets, neural networks, gaze detection, text tagging}


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
This document is the specification of the Parham programming language.

\section{Component and Class}
In Parham, a program is a set of components.
A component itself is a set of classes.

Parham has two types of classes: internal and interface.
An internal class is a class which is internal to its container component.
Therefore, it is not possible to extend it.

An interface class is a class whose behavior is partially defined by its container component.
Such classes are extended when the component is instantiated.

Every component except the main component has at least one interface class.
The main component has no explicit interface classes.
It has an implicit interface class whose name is the same as the name of the component.

\section{Declarations}

The body of a component is a set of declarations.
They define the behavior of the component itself or its classes.
Parham supports the following declaration types.
\begin{enumerate}
\item Field declaration
\item Method declaration
\item Constructor declaration
\item Association declaration
\item Instance declaration
\item Inclusion declaration
\end{enumerate}

\subsection{Field declaration}
A field declaration defines a field for a class.
A field declaration specifies the following properties.
\begin{enumerate}
\item Container class
\item Type
\item Name
\item Modifiers
\end{enumerate}
This is an example of a field declaration.
\begin{lstlisting}
Input[Data]
Data
{
	int value;
}
\end{lstlisting}
The type of a field can be a primitive type or an internal class.
The possible modifiers of a field are the following.
\begin{enumerate}
\item\textit{provides}
\item\textit{requires}
\item\textit{const}
\end{enumerate}

\subsection{Method declaration}
\subsection{Constructor declaration}
A constructor initializes an object of a class when it is created.
It is possible to define any number of constructors for a class of a component.
If the programmer does not define any constructor for a class, the compiler defines a default constructor for it whose arguments and body are void.

A constructor has a body.
In addition, it has to call the constructor of the following items to initialize them too.
\begin{enumerate}
\item Map
\item Super
\item Fields whose types are internal classes.
\end{enumerate}
A call to an upper constructor specifies the field that it constructs using one of the following order.
\begin{enumerate}
\item The name of the field. This case is used to initialize a field declaration or a named map declaration.
\item The name of an instance.
\item The name of an instance and an interface class of its component.
\item The name of a class. It is used to initialize a super class.
\item The name of a component
\item The name of a component and an interface class of its component.
\end{enumerate}
If the programmer does not provide a call to an upper constructor and the class has a constructor whose arguments are void, the compiler adds a call to this constructor.
Otherwise, the compiler generates an error.

\subsection{Association declaration}
\subsection{Instance declaration}
The reusability model of Parham is based on the component concept.
To reuse a component an instance of it should be introduced.
Assume that component \textbf{LinkedList} is declared.
\begin{lstlisting}
LinkedList[Root, Node]
	Root->Node head;
	Node->Node next;
	Root ()
	{
		head = null;
	}
	void Root.insert (Node node)
	{
		node.next = head;
		head = null;
	}
\end{lstlisting}
Now, component \texttt{Observer} can declare an instance of \texttt{LinkedList}.
\begin{lstlisting}
Observer[Subject, Listener]
	LinkedList[Subject, Listener]
\end{lstlisting}
In this example, an instance of \texttt{LinkedList} is declared.
Therefore, \texttt{Observer.Subject} inherits from \texttt{LinkedList.Root} and \texttt{Observer.Listener} inherits from \texttt{LinkedList.Node}.
Of course, it is possible to assign a name to a role.
\begin{lstlisting}
Observer[Subject, Listener]
	LinkedList[Subject subject, Listener]
\end{lstlisting}
A component can instantiate another component any number of times.

When a component is instantiated, the compiler tries to resolve its \textit{requires} methods and fields.
The resolve process is done in two steps.
In the first step, explicit resolving is done.
In this step, the \textit{requires} methods that the programmer explicitly has specified are resolved.
For this purpose, every component instance can have a delegate section where \textit{requires} methods are explicitly resolved.
This is an example of this model.
\begin{lstlisting}
Observer[Sensor, Light]
{
	Listener.notify = x.y.update;
}
\end{lstlisting}
In the above example, the left  side specifies the method which is resolved: \texttt{Listener.notify}.
Recall that the signature of \texttt{Observer} is as follows.
\begin{lstlisting}
Observer[Subject, Listener]
\end{lstlisting}
Therefore, the above resolve section selects class \texttt{Listener}.
It then selects method \texttt{notify} of it.

The right side is as follows.
It specifies an instance, a class and a method of it to resolve.
If there is no ambiguity instance and class names can be omitted.

The implicit resolving is done as follows.
When a component is instantiated its \texttt{requires} methods that have not resolved explicitly or explicitly marked to be resolved again are looked up and if a match was found it is resolved.
Note that if more than one match is found, resolve is not done.
\subsection{Inclusion declaration}

\section{Modifiers}
A declaration may have some modifiers.
Parham supports the following modifiers.
\begin{enumerate}
\item\textit{provides}
\item\textit{requires}
\item\textit{local}
\item\textit{extern}
\item\textit{const}
\end{enumerate}

\subsection{\textit{provides} Modifiers}
In general, everything declared within a component is private to that component.
If something should be accessible from the outside of the component it should be marked by \textit{provides} modifier.
Now, when an instance of the component is declared its declarations that have the \textit{provides} modifier can be accessed to the instantiating component.

The following declarations may have \textit{provides} modifier.
\begin{enumerate}
\item Enumeration types
\item Typedef types
\item Const values
\item Association declarations
\item Component Instances
\item Methods
\item Fields
\end{enumerate}
Note that a constructor has \textit{provides} modifier implicitly.
Therefore, it is not required to mark them by \textit{provides}.

\subsection{\textit{requires} Modifiers}
A component may declare some of its attributes (methods and fields) as \textit{requires}.
It means that when such a component is instantiated the \textit{requires} attributes must be provided.
Of course, if a method is marked as \textit{requires} the component may provide a default behavior for it.
In this case, providing the method is optional.

The first step in providing a \textit{requires} method is to specify such a method.
The interface classes of a component can have \textit{requires} attributes (methods and fields).
The \textit{requires} methods of an interface class of a component are specified using the following rules.
\begin{enumerate}
\item A direct \textit{requires} attribute (method or field)
\item An indirect \textit{requires} attribute (method or field) which has not resolved
\item An indirect \textit{requires} attribute (method or field) which is marked as \textit{requires} again.
\end{enumerate}

Providing an implementation for a \textit{requires} method can be done in two ways.
When a component is instantiated its \textit{requires} methods are specified.
Then, there are two ways to provide implementation for them.
\begin{enumerate}
\item Delegate clause
\item Name matching
\end{enumerate}
This is the description of delegate clause.
Every instance declaration has an optional clause.
This clause may specify implementation for \textit{requires} methods of the instance.

In name matching, when a component is instantiated, its \textit{requires} methods are lookup in the container component and other instance declarations of the component.
If a match is found it is assumed as the implementation of the \textit{requires} method.

Fields are handled in the same way too.

Finally, all \textit{requires} attributes of an internal class must be resolved.
\bibliographystyle{ACM-Reference-Format}
\bibliography{reference}

%%
%% If your work has an appendix, this is the place to put it.
\end{document}
\endinput
%%
%% End of file `sample-acmsmall.tex'.
